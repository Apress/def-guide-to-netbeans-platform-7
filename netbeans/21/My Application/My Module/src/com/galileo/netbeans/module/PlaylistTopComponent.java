/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package com.galileo.netbeans.module;

import java.awt.event.ActionEvent;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.TransferHandler;
import javax.swing.TransferHandler.TransferSupport;
import javax.swing.table.DefaultTableModel;
import org.openide.util.NbBundle;
import org.openide.windows.TopComponent;
import org.netbeans.api.settings.ConvertAsProperties;
import org.netbeans.spi.palette.PaletteActions;
import org.netbeans.spi.palette.PaletteController;
import org.netbeans.spi.palette.PaletteFactory;
import org.openide.awt.ActionID;
import org.openide.awt.ActionReference;
import org.openide.nodes.AbstractNode;
import org.openide.nodes.Children;
import org.openide.nodes.Node;
import org.openide.util.Exceptions;
import org.openide.util.Lookup;
import org.openide.util.lookup.Lookups;

/**
 * Top component which displays something.
 */
@ConvertAsProperties(dtd = "-//com.galileo.netbeans.module//Playlist//EN",
autostore = false)
@TopComponent.Description(preferredID = "PlaylistTopComponent",
//iconBase="SET/PATH/TO/ICON/HERE", 
persistenceType = TopComponent.PERSISTENCE_ALWAYS)
@TopComponent.Registration(mode = "editor", openAtStartup = true)
@ActionID(category = "Window", id = "com.galileo.netbeans.module.PlaylistTopComponent")
@ActionReference(path = "Menu/Window" /*, position = 333 */)
@TopComponent.OpenActionRegistration(displayName = "#CTL_PlaylistAction",
preferredID = "PlaylistTopComponent")
public final class PlaylistTopComponent extends TopComponent {

   private TransferHandler th = new AlbumTransferHandler();
   
   public PlaylistTopComponent() {
      initComponents();
      setName(NbBundle.getMessage(PlaylistTopComponent.class, "CTL_PlaylistTopComponent"));
      setToolTipText(NbBundle.getMessage(PlaylistTopComponent.class, "HINT_PlaylistTopComponent"));
      
      
      albums.setTransferHandler(th);
      scrollPane.setTransferHandler(th);

      Node              r = new AbstractNode(Children.create(new GenreNodeFactory(), false));
      PaletteActions    a = new MyPaletteActions();
      PaletteController p = PaletteFactory.createPalette(r, a);

      associateLookup(Lookups.fixed(p));

//      try {
//         associateLookup(Lookups.fixed(PaletteFactory.createPalette("MyItems", new MyActions())));
//      }
//      catch(Exception e) {
//         e.printStackTrace();
//      }
   }

   
   private final class AlbumTransferHandler extends TransferHandler {
      @Override
      public boolean canImport(TransferSupport support) {
         return support.isDataFlavorSupported(Album.DATA_FLAVOR);
      }

      @Override
      public boolean importData(TransferSupport support) {
         try {
            Album a = (Album)support.getTransferable().getTransferData(Album.DATA_FLAVOR);
            DefaultTableModel model = (DefaultTableModel)albums.getModel();
            model.addRow(new Object[]{a.getTitle(), a.getTracks(), a.getCDs(), a.getYear()});
            return true;
         } catch(Exception e) {
            Exceptions.printStackTrace(e);
            return false;
         }
      }
   }
    
   private static final class MyPaletteActions  extends PaletteActions {
      
      @Override
      public Action[] getImportActions() {
         return new Action[]{};
      }
      
      @Override
      public Action[] getCustomPaletteActions() {
         return new Action[]{};
      }
      
      @Override
      public Action[] getCustomCategoryActions(Lookup arg0) {
         return new Action[]{};
      }
      
      @Override
      public Action[] getCustomItemActions(Lookup arg0) {
         return new Action[]{};
      }
      
      @Override
      public Action getPreferredAction(Lookup arg0) {
         return new AbstractAction() {
            @Override
            public void actionPerformed(ActionEvent arg0) {
               throw new UnsupportedOperationException("Not supported yet.");
            }
         };
      }
   }
   
   /** This method is called from within the constructor to
    * initialize the form.
    * WARNING: Do NOT modify this code. The content of this method is
    * always regenerated by the Form Editor.
    */
      // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
   private void initComponents() {

      scrollPane = new javax.swing.JScrollPane();
      albums = new javax.swing.JTable();

      albums.setAutoCreateRowSorter(true);
      albums.setModel(new javax.swing.table.DefaultTableModel(
         new Object [][] {

         },
         new String [] {
            "Title", "Tracks", "CDs", "Year"
         }
      ) {
         Class[] types = new Class [] {
            java.lang.String.class, java.lang.String.class, java.lang.String.class, java.lang.String.class
         };

         public Class getColumnClass(int columnIndex) {
            return types [columnIndex];
         }
      });
      scrollPane.setViewportView(albums);

      javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
      this.setLayout(layout);
      layout.setHorizontalGroup(
         layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
         .addGap(0, 400, Short.MAX_VALUE)
         .addGroup(layout.createSequentialGroup()
            .addContainerGap()
            .addComponent(scrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 380, Short.MAX_VALUE)
            .addContainerGap())
      );
      layout.setVerticalGroup(
         layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
         .addGap(0, 300, Short.MAX_VALUE)
         .addGroup(layout.createSequentialGroup()
            .addContainerGap()
            .addComponent(scrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 278, Short.MAX_VALUE)
            .addContainerGap())
      );
   }// </editor-fold>//GEN-END:initComponents

      // Variables declaration - do not modify//GEN-BEGIN:variables
   private javax.swing.JTable albums;
   private javax.swing.JScrollPane scrollPane;
   // End of variables declaration//GEN-END:variables
   @Override
   public void componentOpened() {
      // TODO add custom code on component opening
   }

   @Override
   public void componentClosed() {
      // TODO add custom code on component closing
   }

   void writeProperties(java.util.Properties p) {
      // better to version settings since initial version as advocated at
      // http://wiki.apidesign.org/wiki/PropertyFiles
      p.setProperty("version", "1.0");
      // TODO store your settings
   }

   void readProperties(java.util.Properties p) {
      String version = p.getProperty("version");
      // TODO read your settings according to their version
   }
}
